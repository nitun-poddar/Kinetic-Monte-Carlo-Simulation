//this has big arrays for N = 30K with 10^8 (larger number of islands/monomers)#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <stdlib.h>#include <time.h>#define BETA 2.0int numisland;double invbeta = 1.0/BETA;int checkclear(int inew,int jnew);int checkbonds(int xnb,int ynb);//#define NOISLAND //this means don't deposit on top of island#define NRUN 1 // number of runs#define N 45000 // system size 38400#define BALL  2 //only ballistic here double hotrate=1.e9;//this is for ballistic or hot thermal#define CMIN 1.e-5 // this is minimum coverage#define CMAX 0.2 // this is maximum coverage (volume fraction)#define NDATA 500// number of data points// main parameters//#define GRAPH//#define NN 60.0 // picture sizeint idisplay=0;int iitest=0;unsigned char *h; //h[N][N];//unsigned char h[N][N];unsigned char *imark;  //imark[N][N];//unsigned char imark[N][N];//int *spiralseednum;//spiral number  EMM//int spiralseednum[N][N];//spiral number#define nn (N*N)//number of sites//int *ipointa;//ipointa[nn];//EMMint *jointa;//ointa[nn];//int ipointa[nn];//int h[N][N],imark[N][N];#define MAXISLCNT 5000000#define MAXISLSIZE 1000000#define MAXNUMMONOMERS  2000000double CAPTURE=100.0;void takecapavdata(int idata,double CAPTURE);//number of attachments per islandint dira[MAXNUMMONOMERS];int list[MAXNUMMONOMERS],lenwalka[MAXNUMMONOMERS];//int seedi[10000], seedj[10000];//position of seed for each spiralint spiralseedi[MAXISLCNT];//i of each spiral seedint spiralseedj[MAXISLCNT];//j of each spiral seed//int islsiza[800000];int spiralsize[MAXISLCNT];//size of each spiral /////////////////////////////////////double tree[4][8],Rate[8];int nw[8],ip[N],im[N];float  scale=0.05/(N/40);float size = 0.025/(N/40);//float  scale=0.05;//float size = 0.025;int  kWindowWidth = 600; int  kWindowHeight =600;int  kWindowDepth = 0;//#include "graphics.h"//#include "savehts.h"#define NDATAp1 (NDATA+2)#define NCAP 5//data points for capture routine(+1)//values from the Filimonov paper#define NDIR 6 // number of directions for diffusion#define NDIRM 5 // NDIR - 1#define nn6 (N*N*NDIR) //number of sites * number of directions#define nn6small (N*N*NDIR)//#define SEED time(NULL) //305  Changed this to a random seed to give me peace of mind- Brad#define SEED 4305  //Changed this to a random seed to give me peace of mind- Brad// main parametersdouble pi,diffq;double pbarr=1.0;#define DEBUG 0/* run parameters *//* here are some globals */// these are initialized by createspiral()////int numring[1000];//number in each ring (1 in ring 0)int spiralringi[110][1000],spiralringj[110][1000];  //i,j coords relative to seed for given ring number and number in ringint spiraltemplatei[800000],spiraltemplatej[800000];int sumring[110];//total number over all rings/////int seednum=0;//number of clusters so far////int spiralmember[N][N];//points to seed number if part of cluster -> initialize to -1int numspirals=0;//number of spirals so far//int seedi[10000], seedj[10000];//position of seed for each spiral/////////////////////////////////////double tree[4][8],Rate[8];int nw[8],ip[N],im[N];  //int list[8][nn6small];//types are 0 (thermal monomer), 1 (thermal 1-bond), 2(ballistic)unsigned long poww2(int j);int idata;int ideposit=0;int idiffuse=0;double suni(),xdouble,uni();int isize, islcnta[5][MAXISLSIZE],isizemax,x;int numisizea[MAXISLSIZE],ismax,ismaxi;double cova[NDATAp1];//array of coverages at which densa and mondensa// are filled double dxcov,xnsq,xattach,xattachcount;double sigma[5][MAXISLSIZE],flsigma[5][MAXISLSIZE],sigma2[5][MAXISLSIZE];double avsigma[NCAP],avsigma2[NCAP],flavsigma[NCAP],avmonden,mondensbeg;double tsigma[MAXISLSIZE];int ct[MAXISLSIZE];int skip;int countflag;double mondensa[NDATAp1];//monomer density array (as function of coverage)double nwa[NDATAp1];//walker density array (as function of coverage)double densa[NDATAp1];//island density array (as function of coverage)double dens3a[NDATAp1];//island density array (as function of coverage)double dens7a[NDATAp1];//island density array (as function of coverage)double cap1a[5];double capava[5];double sdnrun,dnrun;double sav;double sava[5];double savloga[NDATAp1];//array to save log data inint nbxa[N][10], nbya[N][10];int nwt,ivar;int np,npmax,npincr;double rnddf,rnddf1,rnddf2;double wa[NDATAp1],skewa[NDATAp1];int iii,jjj;FILE *wdata,*picure,*skdata,*tandata,*ggdata,*pixdata,*slopedat;FILE *dist1,*dist2,*dist3,*dist4,*dist5;FILE *logdist1,*logdist2,*logdist3,*logdist4,*logdist5;int hmax;double cth,sth;double covlog;void add(int isite,int idir);//void upnbhd(int i, int j);//void update(int i, int j);void sumtree();void delete (int isite);void uptree(int index);void capnum(int icdata);void findislandsize();void deposit();void diffuse();void takelogdata (int ilogdata);void takedistdata ();void check(int i, int j, int numcl);void createspiral();void addspiral();void addtospiral(int ii,int jj);void createwalker(int i,int j);void buildrings(int numrings);void othercases(int i, int j,int dirr);int numWalker=0;int pick=0;int nsq;FILE *densdata,*picdata,*capavdata,*capdist1,*capdist2,*capdist3,*capdist4,*capdist5,*picdata2;/* end of globals */int main(){  int   long jseed,icdata;  //  int i,j,k,ih,totaldropped;  //  float xii,xjj;double xx;  //  double deprate,totaldiff,totalRate,xtemp;  double deprate, totalRate,dcov,covv,cov,logdcov;  double chance=0;  double dmsigma,msigma,density;  double numLayers=0;  double xtemp,xx,yy,zz,x1,sig1,sig2,sig3,x;  double logx,logy,logz,covnext,covfactor;  int numtotal,iloop,irun,totaldropped,ilogdata;  int index=0;  int counter=0;  int i=0;  int j=0;  int k=0;  int jjlog;  double savvlog,totaldiff,sum,sumxx;  void sgisave();    //graphics  //  size = 0.025;  double temperature=700.0; //temperature of the system  double kb=8.617e-5; //boltzman in eV/K  double v_mono=1e13/6.0; //frequency for monomer hopping / 6 since there are six directions  double Es=0.6;//monomer diffusion energy barrier  //  double Eb=atof(argv[1]);//0.65; //detachment barrier  double Ee=0.6; //edge diffusion barrier 0.6 for fast diffusion and 10 for slow  double kT=kb*temperature;  double DoF=2.4e9;// D/F    double r1det;  //not used  double flux=1.0;//1.0;//diffrate/DoF;  //2.5e-4;//1.0;//this is deposition rate    h = (unsigned char *)malloc(sizeof(unsigned char)*(N*N));  imark = (unsigned char *)malloc(sizeof(unsigned char)*(N*N));  jointa = (int *)malloc(sizeof(int)*(N*N));  //  spiralseednum = (int *)malloc(sizeof(int)*(N*N));  //printf("just entered main\n");  dnrun = (double) NRUN;  sdnrun = sqrt(dnrun-1.0);  if (NRUN==1) sdnrun=1.0;  xnsq=N*N;  dcov=CMAX/5;  xnsq = (double) xnsq;    jseed=SEED;  xdouble=suni(jseed);  /*  capdata=fopen("captri2bdN200r6e5r1test-1r-0.2ML.txt","w");  capdist1=fopen("cap2ddistkmcN3500r1e10-10r-06ML-2.txt","w");  capdist2=fopen("cap2ddistkmcN3500r1e10-10r-12ML-2.txt","w");  capdist3=fopen("cap2ddistkmcN3500r1e10-10r-18ML-2.txt","w");  capdist4=fopen("cap2ddistkmcN3500r1e10-10r-24ML-2.txt","w");  capdist5=fopen("cap2ddistkmcN200r6e5r1test-20r-0.2ML.txt","w");  */  capavdata=fopen("capavspiralemb2p0N45kn4-hot9-1r-.2ML","w");  capdist1=fopen("capspiralemb2p0N45kn4-hot9-1r-.04ML","w");  capdist2=fopen("capspiralemb2p0N45kn4-hot9-1r-.08ML","w");  capdist3=fopen("capspiralemb2p0N45kn4-hot9-1r-.12ML","w");  capdist4=fopen("capspiralemb2p0N45kn4-hot9-1r-.16ML","w");  capdist5=fopen("capspiralemb2p0N45kn4-hot9-1r-.2ML","w");  densdata=fopen("densspiralemb2p0N45kn4-hot9-1r-.2ML","w");  dist1=fopen("isdspiralemb2p0N45kn4-hot9-1r-.04ML","w");  dist2=fopen("isdspiralemb2p0N45kn4-hot9-1r-.08ML","w");  dist3=fopen("isdspiralemb2p0N45kn4-hot9-1r-.12ML","w");  dist4=fopen("isdspiralemb2p0N45kn4-hot9-1r-.16ML","w");  dist5=fopen("isdspiralemb2p0N45kn4-hot9-1r-.2ML","w");  picdata=fopen("readfile","w");  nsq=N*N;  printf("about to initialize direction arrays\n");  // now initialize direction pointers nbxa, nbya  for(i=0;i<N;i++){    ip[i]=i+1;    im[i]=i-1;  }                                                       ip[N-1]=0;  im[0]=N-1;  //c now to initialize i2pmx[n,0:5],i2pmy[n,0:5]  //c basis directions are -> (1) and _\| (SE, 2)  //c  for(i=0;i<N;i++){    //c dir 0 is -> (E)    nbxa[i][0]=ip[i];    nbya[i][0]=i;    //c    //c dir 1 is SE    nbxa[i][1]=ip[i];    nbya[i][1]=im[i];    //c    //c dir 2 is SW    nbxa[i][2]=i;    nbya[i][2]=im[i];    //c    //c dir 3 is W    nbxa[i][3]=im[i];    nbya[i][3]=i;    //c    //c dir 4 is NW    nbxa[i][4]=im[i];    nbya[i][4]=ip[i];    //c    //c dir 5 is NE    nbxa[i][5]=i;    nbya[i][5]=ip[i];  }  /*    c types of moves:    c  monomer (0)    c  1-bond edge-diffuse (1-1)  (1)  r1edge   1-bond    c  1-bond detach (bond dir+3,+2,+4)  (2)  r1det 1-bond    c  2-2 diffuse (bond dirs+2')  (3)  r2edge    c  2-bond detach (bond dirs + 3)  (4)   r2det    c  2-1  (corner)    (rc)  (5)   r2c    cc  1-2  (corner)   (1/rc ?) (6)  r1c  1-bond  */    //  createspiral();//this makes spiralseedi(isize),spiralseedj(isize)  //  abort();  for(i=0;i<8;i++){    printf("rate(%d)=%f\n",i,Rate[i]);  }  // now initialize data arrays nwa[NDATAp1]  etc.  for(i=0;i<NDATAp1;i++){    nwa[i]=0;     mondensa[i]=0;    densa[i]=0;     dens3a[i]=0;     dens7a[i]=0;   }  for(i=0;i<5;i++){    capava[i]=0;    cap1a[i]=0;    for(j=0;j<MAXISLSIZE;j++){      islcnta[i][j]=0;    }  }  isizemax=0;      for (i=0;i<NCAP;i++){  for(j=0;j<MAXISLSIZE;i++) {    numisizea[j]=0;    tsigma[j]=0.0;      ct[j]=0; //this is the counter for capture number    }  }    for(i=0;i<NCAP;i++) {    avsigma[i]=0;    avsigma2[i]=0;    for(j=0;j<MAXISLSIZE;j++) {      sigma[i][j]=0.0;      sigma2[i][j]=0.0;    }  }    for(irun=0;irun < NRUN;irun++){    //main part of the code    //  buildrings(100);//this creates spiraltemplatei[spsize],spiraltemplatej[spsize]  buildrings(99);//this creates spiraltemplatei[spsize],spiraltemplatej[spsize]  //  abort();    printf("irun=%d\n",irun);	      idata=-1;    ilogdata=0;     ideposit=0;    countflag=0;    isizemax=0;    skip=0;    covnext=CMIN;    covfactor=(log(CMAX)-log(CMIN))/(NDATA);    covfactor=exp(covfactor);    printf("covfactor=%g\n",covfactor);    for (i=0;i<N;i++)    {// set lattice heights to zero       for (j=0;j<N;j++)	{	h[i*N+j]='0';	//	spiralseednum[i*N+j]=-1;	jointa[i*N+j]=0;	}    }      seednum=0;    //initialize indexa, ipointa, nw     /*    for(i=0;i<nn;i++){      ipointa[i]=-1;    }    */    for(i=0;i<MAXNUMMONOMERS;i++){      dira[i]=-1;    }    /*    for (i=0;i<N;i++){// initialize the lists       for (j=0;j<N;j++){	upnbhd(i,j);	      }        }    */  //EMM        // initialize base of tree (is this necessary?)    for(i=0;i<4;i++) {         nw[i]=0;//this line was commented out -brad // number of atoms of type i = 0      tree[2][i]=0.0;//nw[i]*Rate[i];    }        //    sumtree();        for(i=0;i<8;i++){      printf("nw[%d]=%d\n",i,nw[i]);    }    printf("deprate=%g\n",deprate);            xx=CMAX*N*N;    totaldropped=(int) (xx+0.5);    //        totaldropped=2;    deprate=N*N;    printf("xx=%g totaldropped=%d\n",xx,totaldropped);    printf("about to start main loop deprate=%g hotrate=%g \n",deprate,hotrate);            //    while (ideposit <= totaldropped+1 || nw[0] !=0){    while (ideposit <= totaldropped+1){      totaldiff = nw[0]*hotrate;        //      totaldiff = nw[0]*diffrate+nw[1]*detachrate+nw[2]*hotrate; //NO TREE      totalRate = deprate + totaldiff;      xtemp=totalRate*uni();      //      if (xtemp <= deprate || ideposit <=3000000 ){      if (xtemp <= deprate || ideposit <=2 ){	cov=(float)ideposit/xnsq;	if(cov >= covnext){ 	  cova[ilogdata]=cov; 	  //	  cleanupspirals();//this does everything I have no idea what this does	  	  takelogdata(ilogdata);	  ilogdata++;	  printf("ilogdata=%d\n",ilogdata);	  //	  if(ilogdata==113)goto endit;	  //	printf("ideposit=%d nw[0]=%d nw[1]=%d nw[2]=%d nw[3]=%d\n",ideposit,nw[0],nw[1],nw[2],nw[3]);	  covnext=covnext*covfactor;	}		/* about to deposit */	/* test for time to take isd data (5 intervals) */	if (cov >= (idata+2)*dcov){ 	  idata++;			    	  //printf("idata=%d\n",idata);	  	  takedistdata(); 	  if(nw[0]!=0 && numisland !=0){	    printf("ilogdata= %d call takecapavdata\n",ilogdata);	    	    	    	    	    takecapavdata(idata,CAPTURE);//number of attachments per island	    	    printf("just returned from takecapavdata\n");		    //		    abort();	}	//		  if (cov >= (idata+1)*dcov && cov < (idata+1)*dcov*1.05)  {	//	  }/*end of if testing for cov in interval and idata condition satisfied*/	}	deposit();	//	printf("we just returned from deposit()\n");	ideposit++;	//	printf("ideposit=%d\n",ideposit);	//	if(ideposit==69)goto writeit;	//	printf("ideposit=%d nw[0]=%d nw[1]=%d nw[2]=%d nw[3]=%d\n",ideposit,nw[0],nw[1],nw[2],nw[3]);	//	if(ideposit==2)abort();      }      else		  	{	 	  diffuse();	}      //      printf("this is end of dep loop\n");    }/* end of deposition loop */      printf("this is end of irun loop\n");  }/* loop over irun */ endit:  printf("seednum=%d\n",seednum);  int icov=0;  /*  for(i=0;i<N;i++){    for(j=0;j<N;j++){      if(h[i][j]!='0'){		printf("%d %d %d\n",i,j,spiralseednum[i][j]);	if(h[i][j]!='1')printf("i=%d j=%d h=%c\n",i,j,h[i][j]);	icov++;      }}}    printf("icov=%d\n",icov);    int ii=spiralseednum[9][9];    printf("i=9 j=9 h[9][9]=%c spiralseednum[9][9]=%d spiralseedij[iseednum]=%d %d\n",h[9][9],spiralseednum[9][9],spiralseedi[ii],spiralseedj[ii]);  */   writeit:  printf("now to save data\n");  for(i=0;i<N;i++){    for(j=0;j<N;j++){      //      fprintf(picdata,"%c\n",h[i][j]);    }}    ///////////////////////////////////////////////////////////////////////  ////////////////////////////////////NITUN SIGS output: fprintf(densdata,"N=%d hotrate=%g  CMAX=%g NRUN=%d BETA=%g\n",N,hotrate,CMAX,NRUN,BETA);     printf("***we are at output and cov=%g\n",cov);    //fprintf(densdata,"covv    mondens    isldens    walker-dens\n");      fprintf(dist1,"s  Ns     s/S      f(u)    sav  \n");    fprintf(dist2,"s  Ns     s/S      f(u)    sav  \n");    fprintf(dist3,"s  Ns     s/S      f(u)    sav  \n");    fprintf(dist4,"s  Ns     s/S      f(u)    sav  \n");    fprintf(dist5,"s  Ns     s/S      f(u)    sav  \n");    //    fprintf(capdata,"N=%d d/f=%g CMAX=%g\n",N,hotrate,CMAX);       //    fprintf(capdata,"cov avsigma\n");            //printf("*********\n");  fprintf(densdata,"covv mondens dens2p \n");  for (i=0;i<NDATAp1;i++) {    covv=cova[i];    x1=mondensa[i]/(xnsq*NRUN); /* monomer density */    xx=densa[i]/(xnsq*NRUN); /* island density */    double yy=xnsq*NRUN;    fprintf(densdata,"%g  %g       %g       \n",covv,x1,xx);  }  //printf("printed density data\n");  /* now to output island-size distributions */       /*output average capture number data */ fprintf(capavdata,"cov  isldensity sigav\n");for(i=0;i<5;i++){	cov=(i+1)*CMAX*.2;	xx=0.0;    for(j=2;j<=isizemax;j++){      xx=xx+islcnta[i][j];    }    fprintf(capavdata,"%g      %g  %g           \n",cov,xx,capava[i]); }//end of i loop    fprintf(capdist1,"s  sigma_s       s/Sav sigma/avsigma\n");    fprintf(capdist2,"s  sigma_s       s/Sav sigma/avsigma\n");    fprintf(capdist3,"s  sigma_s       s/Sav sigma/avsigma\n");    fprintf(capdist4,"s  sigma_s       s/Sav sigma/avsigma\n");    fprintf(capdist5,"s  sigma_s       s/Sav sigma/avsigma\n");  for(i=0;i<5;i++){    cov=(i+1)*CMAX*.2;    xx=0; yy=0; zz=0; sav=0; double sigav=0;    for(j=2;j<=isizemax;j++){      xx=xx+islcnta[i][j];      yy=yy+j*islcnta[i][j];      zz=zz+sigma[i][j]*islcnta[i][j];    }// end of first j loop    sav=yy/xx;    sigav=zz/xx;    printf("sigav=%g capav=%g\n",sigav,capava[i]/NRUN);    for(j=2;j<=isizemax;j++){	//printf("j\n");	xx=islcnta[i][j]/(xnsq*NRUN);	yy=j/sav;	zz=xx*sav*sav/cov;		if(sigma[i][j]!=0 && i==0)fprintf(capdist1,"%d %g           %g           %g\n",j,sigma[i][j]/NRUN,(double)j/sav,sigma[i][j]/sigav);	if(sigma[i][j]!=0 && i==1)fprintf(capdist2,"%d %g           %g           %g\n",j,sigma[i][j]/NRUN,(double)j/sav,sigma[i][j]/sigav);	if(sigma[i][j]!=0 && i==2)fprintf(capdist3,"%d %g           %g           %g\n",j,sigma[i][j]/NRUN,(double)j/sav,sigma[i][j]/sigav);	if(sigma[i][j]!=0 && i==3)fprintf(capdist4,"%d %g           %g           %g\n",j,sigma[i][j]/NRUN,(double)j/sav,sigma[i][j]/sigav);	if(sigma[i][j]!=0 && i==4)fprintf(capdist5,"%d %g           %g           %g\n",j,sigma[i][j]/NRUN,(double)j/sav,sigma[i][j]/sigav);      	if(xx!=0)  	  {	    //printf("yy\n");	    if(i==0) fprintf(dist1,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==1) fprintf(dist2,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==2) fprintf(dist3,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==3) fprintf(dist4,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==4) fprintf(dist5,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	  }	      }/* end of loop over j */    //printf("end of j loop \n");    }/* end of loop over i */  //printf("end of main loop \n");  ///////////////////////////////////////////////////////////////  /////////////////////////////////NITUN SIGS}/* end of main */void takelogdata (int ilogdata){  int i,j,k,numcl,icntr;  numcl=0;    printf("just entered takelogdata\n");  for(i=0;i<N;i++){    for(j=0;j<N;j++){      imark[i*N+j]='0';    }}    for(i=0;i<N;i++){    for(j=0;j<N;j++){      if(h[i*N+j]>'0' && imark[i*N+j]=='0') 	{	  numcl++;isize=1;imark[i*N+j]='1';	  check(i,j,numcl);// this is recursive call	  if(isize==1)mondensa[ilogdata]=mondensa[ilogdata]+1;	  if(isize>=2)densa[ilogdata]=densa[ilogdata]+1;	  if(isize>=3)dens3a[ilogdata]=dens3a[ilogdata]+1;	  if(isize>=7)dens7a[ilogdata]=dens7a[ilogdata]+1;	}    }/* end of j  =0-N loop */  }/* end of i  =0-N loop */  printf("about to leave1 takelogdata\n");  nwa[ilogdata]=nwa[ilogdata]+nw[0]; // walker density  printf("about to leave2 takelogdata\n");}/* end of takelogdata */void takedistdata (){  int i,j,k,numcl;  double x,y;  for(i=0;i<MAXISLSIZE;i++) {    numisizea[i]=0;}/* I added(jga) this here */    for(i=0;i<N;i++){    for(j=0;j<N;j++){      imark[i*N+j]='0';      numcl=0;    }}  numisland=0;  for(i=0;i<N;i++){    for(j=0;j<N;j++){      if(h[i*N+j]>'0' && imark[i*N+j]=='0'){	numcl++;isize=1;imark[i*N+j]='1';	check(i,j,numcl);	islcnta[idata][isize]=islcnta[idata][isize]+1;	numisland++;	numisizea[isize]=islcnta[idata][isize];	if(isize > isizemax)isizemax=isize;      }    }}/* i,j loop over system */  printf("in takedistdata isizemax=%d\n",isizemax);  /* I added(jga) this */   x=0;  y=0;  for(i=2;i<=isizemax;i++){    y=y+islcnta[idata][i];    x=x+i*islcnta[idata][i];}  sava[idata]=x/y;  printf("sava[%d]=%g\n",idata,sava[idata]);  /* I added(jga) this */     }/* end of takedistdata */void check(int i, int j, int numcl){  int inb,jnb,knb,idir;  for(idir=0;idir<NDIR;idir++){    inb=nbxa[i][idir];    jnb=nbya[j][idir];    if(inb<0 || inb >= N){printf("in check inb=%d\n",inb);abort();}    if(jnb<0 || jnb >= N){printf("in check jnb=%d\n",jnb);abort();}    if(h[inb*N+jnb] >'0' && imark[inb*N+jnb]=='0'){      isize++;imark[inb*N+jnb]='1';      check(inb,jnb,numcl);}  }}void deposit() {  int i,j,k,dir,index,isite,idir,isitesh,isite2,index2,dir2,ipos,ilen;  unsigned char hc;  int ii,jj,inum,imons,ispirals,iloop;  int iispirala[10],jjspirala[10],iimona[10],jjmona[10];  //randomly pick site to deposit#ifdef NOISLAND  hc='1';//don't deposit on top of islands !!!    while(hc!='0'){//don't deposit on top of islands !!!#endif  i = N*uni();  if(i==N)i=N-1;  j = N*uni();  if(j==N)j=N-1;  //    if(ideposit < 3000000){  i=N/2-2;j=N/2;}  //    if(ideposit < 2){  i=N/2-2;j=N/2;}  //    printf("we are in deposit i=%d j=%d ideposit=%d\n",i,j,ideposit);  hc=h[i*N+j];#ifdef NOISLAND    }//don't deposit on top of islands !!!#endif  hc++;  h[i*N+j]=hc;  //we have 5 cases:  //  (1) deposited on walker -> create spiral, and move to first spiral position  //  (2) deposited on island -> add to spiral, and move to next spiral position  if(hc=='2'){//landed on walker or spiral    h[i*N+j]--;//remove extra height and move to next place in spiral    //    if(spiralseednum[i][j]==-1){//landed on monomer    //    if(ipointa[i*N+j]!=-1){//landed on monomer    if(jointa[i*N+j]>0){//landed on monomer      //            printf("landed on monomer\n");      //createspiral      delete(i*N+j);//delete monomer      seednum++;//createspiral //new seed  1-based  EMM      //      spiralseednum[i*N+j]=seednum;//createspiral - start at -1  EMM      jointa[i*N+j]=-seednum;//createspiral - start at -1  EMM      spiralseedi[seednum]=i;//createspiral      spiralseedj[seednum]=j;//createspiral      spiralsize[seednum]=0;//seed (size 0) is at (i,j)      //      seednum++;//createspiral //new seed        //      addtospiral(i,j);//this knows spiralsize(i,j);    }    else {//landed on spiral -> so add to spiral      //      inum=spiralseednum[i*N+j];      inum=-jointa[i*N+j];// EMM      ii=spiralseedi[inum];jj=spiralseedj[inum];      //      printf("landed on spiral call add with seed coords ii=%d jj=%d\n",ii,jj);      addtospiral(ii,jj);//add to spiral whose seed is at (ii,jj)    }   return;  }/* end of if hc==2 */  //  printf("landed on substrate\n");  othercases(i,j,-1);//landed on substrate  //  printf("we returned from othercases -1\n");  //     return;}/* end of void deposit() */void othercases(int i,int j,int dirr){  //three other possible cases:  //  (3) deposited on bare substrate away from anything -> create walker if dirr==-1  //  (4) deposited on bare substrate next to walker(s) -> create spiral, and move self to first spiral position, and other walkers to next positions  //  (5) deposited on bare substrate next to island(s) and/or walker(s) -> move self and walkers to next spiral positions  //let's look at nbors and count monomers and spirals  int ichk,ii,jj,isitesh,ipick;  int inum,imons,ispirals,iloop;    int iimona[10],jjmona[10],iispirala[10],jjspirala[10];    //    if(idiffuse==92 || idiffuse==93)    printf("we are in othercases idiffuse=%d\n",idiffuse);  imons=0;  ispirals=0;  for(ichk=0;ichk<NDIR;ichk++){  //let's look at nbors and count monomers and spirals    ii=nbxa[i][ichk];    jj=nbya[j][ichk];    if(h[ii*N+jj]=='0') continue;      //otherwise update list of spirals and walkers    //        if(spiralseednum[ii][jj]==-1){//walker (not spiral)    //	      if(ipointa[ii*N+jj]!=-1){//walker (not spiral)	      if(jointa[ii*N+jj]>0){//walker (not spiral)  EMM	iimona[imons]=ii;jjmona[imons]=jj;	imons++;      }      else {	iispirala[ispirals]=ii;	jjspirala[ispirals]=jj;	ispirals++;      }  }/* end of loop over ichk */  //  printf("dirr=%d imons=%d ispirals=%d\n",dirr,imons,ispirals);  //  if(ispirals>1)abort();  //so we landed on bare substrate  if(imons==0 && ispirals==0){//if no nbrs then add walker at this site    if(dirr==-1)createwalker(i,j);    return;//we are done after adding the walker  }  //so we do have neighbors  //  if(i!=9 || j!=9){      h[i*N+j]='0';//first delete ourselves (we will be added back when adding to spiral)      //  }      /*      if(i==9 && j==9){printf("here 1 i=9 & j=9 is being set to 0\n");	printf("dirr=%d\n",dirr);	//	h[9][9]='1';  picdata2=fopen("readfile2","w");  for(i=0;i<N;i++){    for(j=0;j<N;j++){      fprintf(picdata2,"%c\n",h[i][j]);    }}  //abort();      }      */      if(dirr!=-1){//meaning we came from diffuse()	//	printf("to delete ourselves from walker list i=%d j=%d h=%c\n",i,j,h[i][j]);delete(i*N+j);//delete ourselves from walker list as well if from diffuse()       }	    //delete(i*N+j);//delete ourselves from walker list as well if from diffuse()   if(imons!=0){    for(iloop=0;iloop<imons;iloop++){//delete old walkers if any from substrate       //since they will be moved to spiral locations      ii=iimona[iloop];      jj=jjmona[iloop];      //      ii=nbxa[i][ibmona[iloop]];      //      jj=nbya[j][ibmona[iloop]];      h[ii*N+jj]='0'; //delete this walker       isitesh=ii*N+jj;      //      printf("to delete neighboring walker from list ii=%d jj=%d h=%c\n",ii,jj,h[ii][jj]);      delete(isitesh);//delete walker from list    }  }  //now to act based on spirals and walkers  if(ispirals==0){//make new spiral    //        printf("ispirals==0 seednum=%d\n",seednum);    //we could be attached to several walkers, make this site the seed    // and add the other walkers to the spiral    //    h[i][j]='1';//we undelete ourselves???      seednum++;//createspiral //new seed  1-based EMM      //      spiralseednum[i*N+j]=seednum;//createspiral      jointa[i*N+j]=-seednum;//createspiral  EMM      spiralseedi[seednum]=i;//createspiral      spiralseedj[seednum]=j;//createspiral      spiralsize[seednum]=-1;//seed (size 0) is at (i,j)      //      h[i][j]='1';//restore the height at the new seed!      //      printf("call addtospiral 1\n");      //      seednum++;//createspiral //new seed      addtospiral(i,j);//add ourselves to selected spiral (if no spiral there then create spiral)  //    ii=i;    jj=j;  }  else {//randomly select spiral    ipick=uni()*ispirals;//first randomly pick one of them    if(ipick==ispirals)ipick=ispirals-1;//now we have picked spiral to grow    i=iispirala[ipick]; j=jjspirala[ipick];    //          printf("call addtospiral 2\n");  addtospiral(i,j);//add ourselves to selected spiral (if no spiral there then create spiral)  //  printf("we returned from adding to spiral 2\n");  }  // now add any additional walkers as needed  if(imons!=0){    for(iloop=0;iloop<imons;iloop++){//add any additional walkers as needed    ii=iimona[iloop];    jj=jjmona[iloop];    h[ii*N+jj]='0';//set neighbors to zero before moving them to spiral    //NOTE:  this seems repetitive !!!    }    for(iloop=0;iloop<imons;iloop++){//add any additional walkers as needed      //    printf("call addtospiral 3 iloop=%d imons=%d ii=%d jj=%d\n",iloop,imons,ii,jj);      addtospiral(i,j); //add unit to new spiral whose seed is at (i,j)    }  }    return;  }/* end of void othercases */    void addtospiral(int ii,int jj){      int inum,i0,j0,i,j,spsize;      //      inum=spiralseednum[ii*N+jj];      inum=-jointa[ii*N+jj]; //EMM      i0=spiralseedi[inum];      j0=spiralseedj[inum];      //            printf("in addtospiral ii=%d i0=%d jj=%d j0=%d\n",ii,jj,i0,j0);      spiralsize[inum]++;//increase size by 1      spsize=spiralsize[inum];            i=(spiraltemplatei[spsize]+i0+N)%N;//            j=(spiraltemplatej[spsize]+j0+N)%N;	    //	    	    printf("next i,j=%d %d\n",i,j);      while(h[i*N+j]=='1'){	spiralsize[inum]++;//keep increasing size until empty site found      spsize=spiralsize[inum];      i=(spiraltemplatei[spsize]+i0+N)%N;      j=(spiraltemplatej[spsize]+j0+N)%N;      }      //            printf("spsize=%d inum=%d we will add to spiral at i=%d j=%d h=%c\n",spsize,inum,i,j,h[i][j]);      h[i*N+j]='1';//fill new spiral site       //      ipointa[i*N+j]=-1;  EMM      //      spiralseednum[i*N+j]=inum;//point it to spiral number so that seed can be found  EMM      jointa[i*N+j]=-inum;//point it to spiral number so that seed can be found EMM      //            printf("we added to spiral\n");    }/* end of addtospiral(ii,jj) */void createwalker(int i,int j){  int isitesh,dir,ipos,ilen; double xx;    isitesh=(i*N+j);  //set direction  dir=uni()*NDIR;//this is hot direction  !!!  if(dir==NDIR)dir=NDIRM;    add(isitesh,dir);  //set length    //  ipos=ipointa[isitesh];    ipos=jointa[isitesh];//EMM    //  xx=uni();    //  if(xx==0)xx=1;  //  ilen=(int)(1.0/uni());  ilen=(int)pow(1.0/uni(),invbeta);  if(ilen==0)ilen=1;  lenwalka[ipos]=ilen;  }/* end of createwalker(i,j) *//*void upnbhd(int i, int j)// update nbhd of i,j,k{  int inb,jnb,knb,dir2,dir3;  update(i,j);  // update the site itself  for(dir2= 0;dir2<NDIR;dir2++){// update the neighbors    inb=nbxa[i][dir2];    jnb=nbya[j][dir2];      update(inb,jnb);    }  }*/// end of upnbhd  /*void update(int i, int j)  // update i,j{  int icount(int i, int j);  int isite,index,newindex,isitesh;  isitesh=i*N+j;  if(ipointa[isitesh]!=-1){//if walker, then can delete      newindex=icount(i,j);      if(newindex != 0)delete(isitesh);  }} */ //end of update(int i, int j, int dir) */void delete(int isite)   {     int ipos,endsite,endpos;     //     printf("we are in delete\n");     //     abort();     if(nw[0]==0){printf("in delete nw=0!!!\n");abort();}     //     ipos=ipointa[isite];     ipos=jointa[isite];//EMM     endpos=nw[0];     endsite=list[endpos];     if(endpos != ipos)       {	 // move end to hole in list	 list[ipos]=endsite;//move end to hole in list	 dira[ipos]=dira[endpos];	 lenwalka[ipos]=lenwalka[endpos];	 //	 ipointa[endsite]=ipos;//reset pointer for endsite to new position (hole)	 jointa[endsite]=ipos;//reset pointer for endsite to new position (hole)       }     //     ipointa[isite]=-1; //indicate no walker at given site     //       jointa[isite]=0; //indicate no walker at given site  REMOVE THIS?     nw[0]=nw[0]-1;//decrement number of walker of given type     // UPDATE TREE BRANCHES BELONGING TO INDEX     //     uptree(index); //REMOVE IF NO TREE   }/* end of delete (index, isite) */void add(int isite, int idir)   {     //     ipointa[isite]=nw[0];     nw[0]=nw[0]+1;     jointa[isite]=nw[0];//EMM     dira[nw[0]]=idir;     list[nw[0]]=isite;     //     indexta[isite/NDIR]=index; //indicate 0 or 1 type walker at given site     //     dira[isite/NDIR]=-1; //this is thermal diffuser     // UPDATE TREE BRANCHES BELONGING TO INDEX     //     uptree(index); //REMOVE IF NO TREE}/* end of add(int index, int isite)*/       int icount(int i, int j) // this determines class of particle {     // here we only check for monomer (bond in any direction)  int inb, jnb, knb, idir,nbonds,dirp,dirm,hnew,iidir,isite,isitesh;  int icount,ibond,ichk,ibonda[6],nchk,nchk1,nchk2;  int bdira[10];  unsigned char hx;  //check to make sure not blocked "bonded" in direction  isitesh=i*N+j;  //  isite=ipointa[isitesh];  isite=jointa[isitesh];//EMM        hx=h[i*N+j];    if(hx=='0'){return(-1);}    //        printf("we just entered icount with h!=0 i=%d j=%d dir=%d\n",i,j,dir);	//        printf("nw0=%d nw1=%d  nw2=%d nw3=%d nw4=%d\n",nw[0],nw[1],nw[2],nw[3],nw[4]);  // now count bonds    //    printf("we are now going to count bonds\n");    //  icount=0;  nbonds=0;  for(ichk=0;ichk<NDIR;ichk++){    //    if(h[nbxa[i][ichk]][nbya[j][ichk]]>=hx)  return(-1);    if(h[nbxa[i][ichk]*N+nbya[j][ichk]]>=hx)  return(-1);    }  return(0);//walker !!!}/* end of int icount (int i, int j, int dir)  */void diffuse(){  int x,y,i,j,hxy,a,b,site,isite,isitesh,isitenewsh;     int dir,iwalk,xi,yi,itype;     double xtemp,partial,s1,s2,s3;     int sum,ih,ipos,iposnew;  int xnb,ynb,idir,islmark;  int inb,jnb,ilen;  //  printf("we are in diffuse idiffuse=%d nw[0]=%d iwalk=%d ideposit=%d\n",idiffuse,nw[0],iwalk,ideposit);  iwalk = (int)(uni()*nw[0])+1;//EMM 1-based walker list     if (iwalk==nw[0]+1) iwalk = nw[0]; //fixed JGA 2/26/11            isitesh = list[iwalk];     x     = isitesh/N;     y     = isitesh % N;     dir=dira[iwalk];     //     printf("we are in diffuse iwalk=%d x=%d y=%d dir=%d\n",iwalk,x,y,dir);     //     printf("in diffuse x=%d y=%d itype=%d\n",x,y,itype);  idiffuse++;  //  h[x][y]=h[x][y]-1;  h[x*N+y]--;  xnb=nbxa[x][dir];  ynb=nbya[y][dir];  //  ih=h[xnb][ynb];  h[xnb*N+ynb]++;    isitenewsh=xnb*N+ynb;    //        printf("we are in diffuse xnb=%d ynb=%d  hold=%c hnew=%c\n",xnb,ynb,h[x][y],h[xnb][ynb]);    //        ipos=ipointa[isitesh];    //    ipointa[isitenewsh]=ipos;//add walker at new position    list[iwalk]=isitenewsh;//move walker to new position    //    ipointa[isitenewsh]=iwalk;//move walker to new position    jointa[isitenewsh]=iwalk;//move walker to new position    //    ipointa[isitesh]=-1;//delete walker at old position    jointa[isitesh]=0;//delete walker at old position EMM -> there are no walkers on islands, also +means walker, - means island, 0 means h=0 (empty)    lenwalka[iwalk]=lenwalka[iwalk]-1;  //  printf("we are in diffuse i=%d j=%d h=%d -> in=%d jn=%d h=%d \n",x,y,h[x][y],xnb,ynb,h[xnb][ynb]);    //don't change direction    //generate a new direction and distance every time    //don't change direction for ballistic    if(lenwalka[iwalk]==0){//generate a new direction and distance  dir=uni()*NDIR;//this is hot direction  !!!  if(dir==NDIR)dir=NDIRM;  dira[iwalk]=dir;  //  ilen=(int)(1.0/uni());  ilen=(int)pow(1.0/uni(),invbeta);  if(ilen==0)ilen=1;  lenwalka[iwalk]=ilen;      }    othercases(xnb,ynb,dir);//if this is still a walker then nothing will happen    //however if it is next to other walkers/spirals then it and other walkers will be added to new(old) spirals    //  upnbhd(xnb,ynb);//check to make sure still walker and/or same for nbors  //  printf("diffuse x,y=%d %d  newxy=%d %d  diroldsite=%d dirnewsite=%d\n",x,y,xnb,ynb,dira[isitesh],dira[isitenewsh]);  //  iitest++;  //  if(iitest==2)abort();  //diffusion done}/* end of diffuse () */    /* uni.c */    /* 3D triangulation program written by Isabel Beichl */    /* based on an algorithm designed by Isabel Beichl & Francis Sullivan */    /*    National Institute of Standards & Technology */    /*    Gaithersburg, MD 20899  */          static unsigned long count = 0;    #define BIGCOUNT 10000000    /* how many to do without re-initializing */    static unsigned long m1 = 32767;    static long int mb[607];    /*=    {            30788, 23052, 2053, 19346, 10646, 19427, 23975,            19049, 10949, 19693, 29746, 26748, 2796, 23890,            29168, 31924, 16499    };    */    static int mdig = 32;    static unsigned long m2 = 256;    static int iran = 272;    static int jran = 606;    double suni(jseed)          unsigned long jseed;    {            long int j0, j1, k0, k1;            double uni();    /*      printf(" suni %ld\n", jseed);*/            m1 = poww2(mdig-2) - 1;     /* avoid overflow if m1 is full size */            m1 += m1;            m1++;       /* printf(" m1 %lu, m2 %lu, mdig %d, jseed %u\n", m1, m2, mdig, jseed); */            m2 = poww2((int)(mdig/2));       /* printf(" m1 %lu, m2 %lu, mdig %d, jseed %u\n", m1, m2, mdig, jseed); */            jseed %= m1;                    /* jseed should less than m1 */            if ((jseed & 1) == 0)           /* jseed should be odd */                    jseed--;            k0 = 9069 % m2;                 /* simple congruential generator */            k1 = 9069 / m2;                 /* the fanciness avoids overflow */            j0 = jseed % m2;            j1 = jseed / m2;            for (iran = 0; iran < 607; iran++)            {       jseed = j0*k0;                    j1 = (jseed/m2 + j0*k1 + j1*k0) % (m2/2);                    j0 = jseed % m2;                    mb[iran] = j0 + m2*j1;        /* printf("%2d %10u\n", i, mb[i]); */            }            iran = 272;            jran = 606;            return uni();    }    double uni()    {            long int k;            k = mb[iran] - mb[jran];            if (k < 0)                    k += m1;       /* printf(" In UNI -- k = %ld\n",k); */            if (++count >= BIGCOUNT)            {       count = 0;                    suni(k);            }            else            {       mb[jran] = k;                    if (--iran < 0)                            iran = 606;                    if (--jran < 0)                            jran = 606;            }       /* printf("%lf\n", (double)k/(double)m1); */       /* putchar(k%2 ?'+':'-');*/            return ((double)k/(double)m1);    }unsigned long poww2(int j)    {            unsigned long x = 1;       /* printf("poww2--j= %d\n",j); */            while (j--)                    x *= 2;          /* printf("poww2--x= %lu\n",x); */            return (unsigned long) x;    }    /* end of uni2.c */void sumtree(){     int i,j,nj,a;     nj = 2;     for (i=1;i>=0;i--){          for (j=0;j<nj;j++){               tree[i][j]=tree[i+1][2*j]+tree[i+1][2*j+1];              }          nj = (int) (nj/2);     }}     void uptree(int index){     int i,j,a;     double nwrate;     nwrate = nw[index]*Rate[index];     if (tree[2][index]!=nwrate) {         tree[2][index]=nwrate;         j = (int) (index/2);         for (i=1;i>=0;i--){              tree[i][j]=tree[i+1][2*j]+tree[i+1][2*j+1];	      j = (int) (j/2);         }     }	}     	  /*void createspiral(){FILE *ringdata;  printf("we are here\n");  // now for spiral     int i,j;  int hs[400][400];  int i0=200;  int j0=200;  int irr; int numring[1000];  for(i=0;i<1000;i++){numring[i]=0;}  printf("numring initialized\n");  int spiralringi[200][2000],spiralringj[200][2000];    double dx,dy,rr;  double x0=(double)(i0*N+j0*.5);  double y0=(double)(j0*sqrt(3.0)*0.5);  int iring,inb,jnb,idir,ii,jj,ilist;  //  int numrings=198;  int numrings=198;  ringdata=fopen("ringdata198","w");  numring[0]=1;  spiralringi[0][1]=i0;  spiralringj[0][1]=j0;  hs[i0][j0]=1;  for(iring=1;iring<=numrings;iring++){    ilist=0;    numring[iring]=0;    for(i=1;i<=numring[iring-1];i++){	ii=spiralringi[iring-1][i];	jj=spiralringj[iring-1][i];      for(idir=0;idir<NDIR;idir++){	inb=nbxa[ii][idir];	jnb=nbya[jj][idir];	if(hs[inb][jnb]==0){	  ilist++;	  spiralringi[iring][ilist]=inb;	  spiralringj[iring][ilist]=jnb;	  numring[iring]++;	  hs[inb][jnb]=1;	}      }    }// loop over all members previous ring }// loop to build all rings     sumring[0]=1;  for(i=1;i<100;i++)sumring[i]=0;  for (i=1;i<=numrings;i++){sumring[i]=sumring[i-1]+numring[i];}  for (i=0;i<=numrings;i++){    printf("ringnum=%d numring=%d sumring=%d\n",i,numring[i],sumring[i]);    }  for(iring=0;iring<=numrings;iring++){   for(i=1;i<=numring[iring];i++){     spiralringi[iring][i]=spiralringi[iring][i]-i0;     spiralringj[iring][i]=spiralringj[iring][i]-j0;	  dx=spiralringi[iring][i]+0.5*spiralringj[iring][i];	  dy=sqrt(3.0)*0.5*spiralringj[iring][i];	  fprintf(ringdata,"%d %d %d %f %f\n",i,spiralringi[iring][i],spiralringj[iring][i],dx,dy);  }  }}// end of void createspiral() */  void buildrings (int numrings) {FILE *ringdata; int i,j;  printf("build rings\n");  // now for spiral   int i0=N/2;  int j0=N/2;  int irr;  int numring[2000];  for(i=0;i<2000;i++){numring[i]=0;}  printf("numring initialized\n");  //  int spirali[20000],spiralj[20000];    double dx,dy,rr;  double x0=(double)(i0*N+j0*.5);  double y0=(double)(j0*sqrt(3.0)*0.5);  int iring,inb,jnb,idir,ii,jj,ilist;  //  int numrings=198;  //  int numrings=10;  ringdata=fopen("ringdata10","w");    for (i=0;i<N;i++)    {// set lattice heights to zero       for (j=0;j<N;j++)	{	h[i*N+j]='0';}}  numring[0]=1;  spiralringi[0][1]=i0;  spiralringj[0][1]=j0;  h[i0*N+j0]='1';  spiraltemplatei[0]=0;  spiraltemplatej[0]=0;  int numtot=0;  for(iring=1;iring<=numrings;iring++){    ilist=0;    numring[iring]=0;    for(i=1;i<=numring[iring-1];i++){	ii=spiralringi[iring-1][i];	jj=spiralringj[iring-1][i];      for(idir=0;idir<NDIR;idir++){	inb=nbxa[ii][idir];	jnb=nbya[jj][idir];	if(h[inb*N+jnb]=='0'){	  numtot++;////////////////////	  ilist++;	  spiralringi[iring][ilist]=inb;	  spiralringj[iring][ilist]=jnb;	  //	  int ii=(inb-i0+N)%N;//////////////////	  //	  int jj==(jnb-j0+N)%N;/////////////////	  spiraltemplatei[numtot]=inb-i0;//////////////////	  spiraltemplatej[numtot]=jnb-j0;//////////////////	  numring[iring]++;	  h[inb*N+jnb]='1';	}      }    }/* loop over all members previous ring */  }/* loop to build all rings */  for(i=0;i<numrings;i++){printf("iring=%d numinring=%d\n",i,numring[i]);}  printf("spiraltemplate largestspiralsize=%d  ii=%d jj=%d\n",numtot,spiraltemplatei[numtot],spiraltemplatej[numtot]);  }/* end of void buildrings() */    void takecapavdata (int idata, double countmin) {  double numdiff=0;    double countav=0;    double xcount1=0;    double xcount2p=0;    int iwalk,iwalk2,isitesh,x,y,dir,xnb,ynb,isitenewsh,ilen,inum;    double count1;    int ii,i,j;  for(j=2;j<isizemax;j++){    ct[j]=0;  }#ifdef RESTORE    //first save dira,list, lenwalka, and h    for(i=0;i<nw[0];i++){      dira2[i]=dira[i];      lenwalka2[i]=lenwalka[i];      list2[i]=list[i];      ii=list[i];      h2[i]=h[ii];//this is to restore configuration at end    }#endif    while (countav < countmin){      //pick random walker to move (include only substrate monomers)      iwalk = uni()*nw[0]+1;//1-based walker array     if (iwalk==nw[0]+1) iwalk = nw[0]; //fixed JGA 2/26/11  JGA 10/1/15      isitesh = list[iwalk];      while(h[isitesh]!='1'){//pick only walkers on substrate	iwalk = uni()*nw[0]+1;//1-based walker array     if (iwalk==nw[0]+1) iwalk = nw[0]; //fixed JGA 2/26/11 JGA 10/1/15      isitesh = list[iwalk];      }     dir=dira[iwalk];     x     = isitesh/N;     y     = isitesh % N;     h[isitesh]--;//decrement to 0 walker since it is moving to another site    jointa[isitesh]=0;//remove inverse pointer to old position  numdiff++;  xnb=nbxa[x][dir];//new site  ynb=nbya[y][dir];//new site    isitenewsh=xnb*N+ynb;//move walker to new position  h[isitenewsh]++;//move walker to new position    jointa[isitenewsh]=iwalk;//move walker to new position    list[iwalk]=isitenewsh;//move walker to new position  //  printf("we are in diffuse i=%d j=%d h=%d -> in=%d jn=%d h=%d \n",x,y,h[x][y],xnb,ynb,h[xnb][ynb]);        lenwalka[iwalk]=lenwalka[iwalk]-1;        if(lenwalka[iwalk]==0){//if necessary generate a new direction and persistence length      dir=uni()*NDIR;//this is hot direction  !!!      if(dir==NDIR)dir=NDIRM;      dira[iwalk]=dir;      //      ilen=(int)(1.0/uni());          ilen=(int)(pow(1.0/uni(),invbeta));  if(ilen==0)ilen=1;  lenwalka[iwalk]=ilen;      }       //now check for nbrs - if so then move to random site	int ibond;	ibond = checkbonds(xnb,ynb);//checkbonds returns direction of first bond-site found if any, otherwise it returns -1        if(ibond==-1)continue;//we don't need to place it, we just continue diffusing    int iplace;    h[isitenewsh]--;//it has neighbors so we will move it somewhere else    jointa[isitenewsh]=0;//remove walker at this new site since it has neighbors    int inb,jnb;    inb=nbxa[xnb][ibond];jnb=nbya[ynb][ibond];//this is bond neighbor to count capture number      iwalk2=jointa[inb*N+jnb];      int iadd;    if(iwalk2 > 0 && h[inb*N+jnb]=='1'){//if nbr is substrate monomer then count it and move it too      h[inb*N+jnb]--;//remove the neighboring monomer as well      //      int numclsave=imark[inb*N+jnb];//save numcl for relocating monomer      //      iadd=1;      jointa[inb*N+jnb]=0;//only delete if substrate monomer      //      delete(inb*N+jnb);//delete the neighboring monomer as well      xcount1=xcount1+1;      iplace=2;    }    else      //try just moving monomer{      iplace=1;      //      xcount2p=xcount2p+1;      //      printf("xnb=%d ynb=%d h=%c\n",xnb,ynb,h[xnb*N+ynb]);      if(h[xnb*N+ynb]=='0'){xcount2p=xcount2p+1;       inum=-jointa[inb*N+jnb]; //EMM      ct[spiralsize[inum]]+=1.0;//increase size by 1      //ct[islandsize[imark[inb*N+jnb]]]+=1.0;      }      //      printf("in takecapavdata we just attached to an island! xcountp2=%g\n",xcount2p);    }    //now place original monomer     int inew,jnew;    inew=uni()*N;    if(inew==N)inew=N-1;    jnew=uni()*N;    if(jnew==N)jnew=N-1;    while(checkclear(inew,jnew)==-1){//checkclear returns -1 if height > 0 or any nbrs >0      //      printf("we are in first while checknbrs2\n");    inew=uni()*N;    if(inew==N)inew=N-1;    jnew=uni()*N;    if(jnew==N)jnew=N-1;    }//we found an empty site which had no neighbors    h[inew*N+jnew]++;     list[iwalk]=inew*N+jnew;    jointa[inew*N+jnew]=iwalk;    if(iplace==2){    //we need to place a 2nd monomer      //    if(iwalk2!=-1){    //we need to place a 2nd monomer    inew=uni()*N;    if(inew==N)inew=N-1;    jnew=uni()*N;    if(jnew==N)jnew=N-1;    while(checkclear(inew,jnew)==-1){//checkclear returns -1 if any nbrs are higher      //      printf("we are in second while checknbrs2\n");    inew=uni()*N;    if(inew==N)inew=N-1;    jnew=uni()*N;    if(jnew==N)jnew=N-1;    }//we found an empty site which had no neighbors    h[inew*N+jnew]++;     //    if(iadd==1)iwalk2=nw[0];    list[iwalk2]=inew*N+jnew;    jointa[inew*N+jnew]=iwalk2;    //    if(iadd==1)nw[0]++;    }    countav=xcount2p/(double)numisland;//this is number of captures per island    }/* end of while countav < countmin */    count1=xcount1/(double)nw[0];//this is number of monomer captures per monomer  double dt=numdiff/(hotrate*nw[0]);  double xN=(double)N;  double xN2=xN*xN;  double xN4=xN*xN*xN*xN;  //    countav=xcount2p/(double)numisland;//this is number of captures per island  capava[idata]=capava[idata]+countav*xN2/(nw[0]*hotrate*dt);  cap1a[idata]=cap1a[idata]+count1*xN2/(nw[0]*hotrate*dt*2.0);  int is;  for(is=2;is<isizemax;is++){        if(numisizea[is]!=0)    sigma[idata][is]=sigma[idata][is]+ct[is]*xN2/(nw[0]*hotrate*dt*(double)numisizea[is]);	//if(numisizea[is]!=0)    sigma[idata][is]=sigma[idata][is]+ct[is]*xN2/(nw[0]*hotrate*dt*(double)islcnta[idata][is]);  }//now store in capav and cap1 data#ifdef RESTORE    //now restore dira,list, and lenwalka, and h  for(i=0;i<nw[0];i++){    ii=list[i];    h[ii]=0;//remove all current walkers    ipointa[ii]=-1;  }    for(i=0;i<nw[0];i++){      dira[i]=dira2[i];      lenwalka[i]=lenwalka2[i];      list[i]=list2[i];      ii=list2[i];      h[ii]=h2[i];//this is to restore configuration-> replace with original walkers      ipointa[ii]=i;    }#endif}/* end of takecapavdata */ int checkbonds(int xnb,int ynb){//checkbonds returns direction of first bond-site found if any, otherwise it returns -1   int in,jn,dir;   for(dir=0;dir<NDIR;dir++){     in=nbxa[xnb][dir];jn=nbya[ynb][dir];     //     if(h[in][jn]>=h[xnb][ynb]){return(dir);}          if(h[in*N+jn]>=h[xnb*N+ynb]){return(dir);}   }   return(-1); }  int checkclear(int inew,int jnew) {//NO: checkclear returns -1 if h!=0 YES: or any nbrs are higher   int in,jn,dir;      if(h[inew*N+jnew]!='0')return(-1);//do not place on island or monomer   for(dir=0;dir<NDIR;dir++){     in=nbxa[inew][dir];jn=nbya[jnew][dir];     if(h[in*N+jn]>'0'){return(-1);}   }   return(0);}