// this is modified version of trianglerunnbrad.c  8/21/13#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <stdlib.h>#include <time.h>//#define LEVY#define NRUN 1 // number of runs#define N 60 // system size#define BALL  2 //only ballistic here double hotrate=1.e5;//1.e5;//this is for ballistic or hot thermaldouble rthermal=1.0;//thermal monomersdouble rdetach=0.0;//one-bond detachmentdouble redge=0.0;//one-bond edge-diffusion//double thermalrate,detachrate,edgerate,pdetach;//#define CMIN 1.0e-6 // this is minimum coverage#define CMAX 0.01 // this is maximum coverage (volume fraction)#define NDATA 400// number of data points// main parameters//#define GRAPH//#define NN 60.0 // picture sizeint idisplay=0;int iitest=0;int  h[N][N];//unsigned char h[N][N];unsigned char imark[N][N];#define nn (N*N)//number of sitesint ipointa[nn],indexa[nn];//int h[N][N],imark[N][N];int dira[4][100000];int onebonddir;int list[4][100000],lenwalka[100000];//type 0 is hot monomer, type 1 is thermal monomer and type 2 is 1-bondfloat  scale=0.05/(N/40);float size = 0.025/(N/40);//float  scale=0.05;//float size = 0.025;int  kWindowWidth = 600; int  kWindowHeight =600;int  kWindowDepth = 0;//#include "graphics.h"//#include "savehts.h"#define NDATAp1 (NDATA+2)#define NCAP 5//data points for capture routine(+1)#define NDIR 6 // number of directions for diffusion#define NDIRM 5 // NDIR - 1#define nn6 (N*N*NDIR) //number of sites * number of directions#define nn6small (N*N*NDIR)//#define SEED time(NULL) //305  Changed this to a random seed to give me peace of mind- Brad#define SEED 305#define MAXISLCNT 40000// main parametersdouble pi,diffq;double pbarr=1.0;#define DEBUG 0/* run parameters *//* here are some globals */double tree[3][4],Rate[8];int nw[8],ip[N],im[N];int islsiza[100000];  //int list[8][nn6small];//types are 0 (thermal monomer), 1 (thermal 1-bond), 2(ballistic)unsigned long poww2(int j);int idata;int ideposit=0;int idiffuse=0;double suni(),xdouble,uni();int isize, islcnta[5][MAXISLCNT],isizemax,x;int numisizea[MAXISLCNT],ismax,ismaxi;double cova[NDATAp1];//array of coverages at which densa and mondensa// are filled double dxcov,xnsq,xattach,xattachcount;double sigma[MAXISLCNT][NCAP],flsigma[MAXISLCNT][NCAP],sigma2[MAXISLCNT][NCAP];double avsigma[NCAP],avsigma2[NCAP],flavsigma[NCAP],avmonden,mondensbeg;double isdi[MAXISLCNT];double tsigma[MAXISLCNT];int ct[MAXISLCNT][NCAP];int skip;int countflag;double mondensa[NDATAp1];//monomer density array (as function of coverage)double nwa[NDATAp1];//walker density array (as function of coverage)double densa[NDATAp1];//island density array (as function of coverage)double dens3a[NDATAp1];//island density array (as function of coverage)double dens7a[NDATAp1];//island density array (as function of coverage)double sdnrun,dnrun;double sav;double sava[5];double savloga[NDATAp1];//array to save log data inint nbxa[N][10], nbya[N][10];int nwt,ivar;int np,npmax,npincr;double rnddf,rnddf1,rnddf2;double wa[NDATAp1],skewa[NDATAp1];int iii,jjj;FILE *wdata,*picure,*skdata,*tandata,*ggdata,*pixdata,*slopedat;FILE *dist1,*dist2,*dist3,*dist4,*dist5;FILE *logdist1,*logdist2,*logdist3,*logdist4,*logdist5;int hmax;double cth,sth;double covlog;void delete (int index, int isite);int icount(int i, int j,int dir);//void add(int newindex, int isite,int dir,int bdir);void add(int index, int isite,int idir,int bdir);void upnbhd(int i, int j,int dir);void update(int i, int j,int dir);void sumtree();void uptree(int index);void capnum(int icdata);void findislandsize();void deposit();void diffuse();void takelogdata (int ilogdata);void takedistdata ();void check(int i, int j, int numcl);int numWalker=0;int pick=0;int nsq; FILE *densdata,*picdata,*capdata,*capdivdata,*capdist1,*capdist2,*capdist3,*capdist4,*capdist5;/* end of globals */int main(){  int   long jseed,icdata;  //  int i,j,k,ih,totaldropped;  //  float xii,xjj;double xx;  //  double deprate,totaldiff,totalRate,xtemp;  double deprate, totalRate,dcov,covv,cov,logdcov;  double chance=0;  double dmsigma,msigma,density;  double numLayers=0;  double xtemp,xx,yy,zz,x1,sig1,sig2,sig3;  double logx,logy,logz,covnext,covfactor;  int numtotal,iloop,irun,totaldropped,ilogdata;  int index=0;  int counter=0;  int i=0;  int j=0;  int k=0;  int jjlog;  double savvlog,totaldiff,sum,sumxx;  void sgisave();    //graphics  //  size = 0.025;  double temperature=700.0; //temperature of the system  double kb=8.617e-5; //boltzman in eV/K  double v_mono=1e13/6.0; //frequency for monomer hopping / 6 since there are six directions  double Es=0.6;//monomer diffusion energy barrier  //  double Eb=atof(argv[1]);//0.65; //detachment barrier  double Ee=0.6; //edge diffusion barrier 0.6 for fast diffusion and 10 for slow  double kT=kb*temperature;  double DoF=2.4e9;// D/F    double r1det;  //not used  double flux=1.0;//1.0;//diffrate/DoF;  //2.5e-4;//1.0;//this is deposition rate    //printf("just entered main\n");  dnrun = (double) NRUN;  sdnrun = sqrt(dnrun-1.0);  if (NRUN==1) sdnrun=1.0;  xnsq=N*N;  dcov=CMAX/5;  xnsq = (double) xnsq;    jseed=SEED;  xdouble=suni(jseed);  thermalrate=rthermal*hotrate;  detachrate=rdetach*hotrate;  edgerate=redge*hotrate;  pdetach=detachrate/(detachrate+edgerate);  /*  capdata=fopen("captri2bdN200r6e5r1test-1r-0.2ML.txt","w");  capdist1=fopen("cap2ddistkmcN3500r1e10-10r-06ML-2.txt","w");  capdist2=fopen("cap2ddistkmcN3500r1e10-10r-12ML-2.txt","w");  capdist3=fopen("cap2ddistkmcN3500r1e10-10r-18ML-2.txt","w");  capdist4=fopen("cap2ddistkmcN3500r1e10-10r-24ML-2.txt","w");  capdist5=fopen("cap2ddistkmcN200r6e5r1test-20r-0.2ML.txt","w");  */  densdata=fopen("dens-i2ballcharN1khot8rth1rdet0re0-1r-.1ML","w");  dist1=fopen("isd-i2ballcharN1khot8rth1rdet0re0-1r-.02ML","w");  dist2=fopen("isd-i2ballcharN1khot8rth1rdet0re0-1r-.04ML","w");  dist3=fopen("isd-i2ballcharN1khot8rth1rdet0re0-1r-.06ML","w");  dist4=fopen("isd-i2ballcharN1khot8rth1rdet0re0-1r-.08ML","w");  dist5=fopen("isd-i2ballcharN1khot8rth1rdet0re0-1r-.1ML","w");  picdata=fopen("pic-i2ballcharN1khot8rth1rdet0re0-1r-.1ML.xyz","w");  nsq=N*N;  printf("about to initialize direction arrays\n");  // now initialize direction pointers nbxa, nbya  for(i=0;i<N;i++){    ip[i]=i+1;    im[i]=i-1;  }                                                       ip[N-1]=0;  im[0]=N-1;  //c now to initialize i2pmx[n,0:5],i2pmy[n,0:5]  //c basis directions are -> (1) and _\| (SE, 2)  //c  for(i=0;i<N;i++){    //c dir 0 is -> (E)    nbxa[i][0]=ip[i];    nbya[i][0]=i;    //c    //c dir 1 is SE    nbxa[i][1]=ip[i];    nbya[i][1]=im[i];    //c    //c dir 2 is SW    nbxa[i][2]=i;    nbya[i][2]=im[i];    //c    //c dir 3 is W    nbxa[i][3]=im[i];    nbya[i][3]=i;    //c    //c dir 4 is NW    nbxa[i][4]=im[i];    nbya[i][4]=ip[i];    //c    //c dir 5 is NE    nbxa[i][5]=i;    nbya[i][5]=ip[i];  }  /*    c types of moves:    c  monomer (0)    c  1-bond edge-diffuse (1-1)  (1)  r1edge   1-bond    c  1-bond detach (bond dir+3,+2,+4)  (2)  r1det 1-bond    c  2-2 diffuse (bond dirs+2')  (3)  r2edge    c  2-bond detach (bond dirs + 3)  (4)   r2det    c  2-1  (corner)    (rc)  (5)   r2c    cc  1-2  (corner)   (1/rc ?) (6)  r1c  1-bond  */    for(i=0;i<4;i++){    printf("rate(%d)=%f\n",i,Rate[i]);  }  // now initialize data arrays nwa[NDATAp1]  etc.  for(i=0;i<NDATAp1;i++){    nwa[i]=0;     mondensa[i]=0;    densa[i]=0;     dens3a[i]=0;     dens7a[i]=0;   }  for(i=0;i<5;i++){    for(j=0;j<MAXISLCNT;j++){      islcnta[i][j]=0;    }  }  isizemax=0;    for(i=0;i<MAXISLCNT;i++) {    numisizea[i]=0;    tsigma[i]=0.0;    for (j=0;j<NCAP;j++){      ct[i][j]=0; //this is the counter for capture number    }  }    for(i=0;i<NCAP;i++) {    avsigma[i]=0;    avsigma2[i]=0;    for(j=0;j<MAXISLCNT;j++) {      sigma[j][i]=0.0;      sigma2[j][i]=0.0;    }  }    Rate[0]=hotrate;  Rate[1]=thermalrate;  Rate[2]=detachrate;  Rate[3]=detachrate+edgerate;  for(irun=0;irun < NRUN;irun++){    //main part of the code    printf("irun=%d\n",irun);	      idata=-1;    ilogdata=0;     ideposit=0;    countflag=0;    isizemax=0;    skip=0;    covnext=CMIN;    covfactor=(log(CMAX)-log(CMIN))/(NDATA);    covfactor=exp(covfactor);    printf("covfactor=%g\n",covfactor);    for (i=0;i<N;i++)    {// set lattice heights to zero       for (j=0;j<N;j++)	{	//	h[i][j]='0';	}    }  	h[i][j]=0;	}    }          //initialize indexa, ipointa, nw     for(i=0;i<nn;i++){      ipointa[i]=-1;      indexa[i]=-1;    }    for(int ii=0;ii<4;ii++){    for(i=0;i<100000;i++){      dira[ii][i]=-1;    }}    // initialize base of tree (is this necessary?)    for(i=0;i<4;i++) {         nw[i]=0;//this line was commented out -brad // number of atoms of type i = 0      tree[2][i]=0.0;//nw[i]*Rate[i];    }        sumtree();    for (i=0;i<N;i++){// initialize the lists       for (j=0;j<N;j++){	upnbhd(i,j,-1);	      }        }            for(i=0;i<4;i++){      printf("nw[%d]=%d\n",i,nw[i]);    }    printf("deprate=%g\n",deprate);            xx=CMAX*N*N;    totaldropped=(int) (xx+0.5);    deprate=N*N;    printf("xx=%g totaldropped=%d\n",xx,totaldropped);    printf("about to start main loop deprate=%g hotrate=%g \n",deprate,hotrate);            while (ideposit <= totaldropped+1){      //      totaldiff = nw[0]*hotrate;        totaldiff = tree[0][0];      //      totaldiff = nw[0]*diffrate+nw[1]*detachrate+nw[2]*hotrate; //NO TREE      totalRate = deprate + totaldiff;      xtemp=totalRate*uni();      if (xtemp <= deprate){	cov=(float)ideposit/xnsq;	if(cov >= covnext){ 	  cova[ilogdata]=cov; 	  takelogdata(ilogdata);	  ilogdata++;	  printf("ilogdata=%d\n",ilogdata);	printf("ideposit=%d nw[0]=%d nw[1]=%d nw[2]=%d nw[3]=%d\n",ideposit,nw[0],nw[1],nw[2],nw[3]);	  covnext=covnext*covfactor;	}		/* about to deposit */	/* test for time to take isd data (5 intervals) */	if (cov >= (idata+2)*dcov){ 	  idata++;			    	  //printf("idata=%d\n",idata);	  takedistdata(); 	}	deposit();	ideposit++;	//	printf("ideposit=%d nw[0]=%d nw[1]=%d nw[2]=%d nw[3]=%d\n",ideposit,nw[0],nw[1],nw[2],nw[3]);	//	if(ideposit==2)abort();      }      else		  	{	 	  diffuse();	}    }/* end of deposition loop */  }/* loop over irun */    printf("now to save data\n");  for(i=0;i<N;i++){    for(j=0;j<N;j++){      xx=i+0.5*(double)j; yy=sqrt(3.0)*0.5*j;zz=0.0;      if (h[i][j]!=0)     fprintf(picdata,"Cu %g %g %g \n",xx,yy,zz);      //      if (h[i][j]!='0')     fprintf(picdata,"Cu %g %g %g \n",xx,yy,zz);    }}    //    for(icdata=0;icdata<5;icdata++)      capnum(icdata);    /* now output results */  /* output some densities first */   output: fprintf(densdata,"N=%d hotrate=%g  CMAX=%g\n",N,hotrate,CMAX);     printf("***we are at output and cov=%g\n",cov);    //fprintf(densdata,"covv    mondens    isldens    walker-dens\n");  /*    fprintf(capdata,"N=%d d/f=%g CMAX=%g\n",N,diffrate,CMAX);       fprintf(capdata,"avsigma          avsigma2          flavsigma\n");    fprintf(capdist1,"s/Sav sigma           sigma2      sigma/avsigma\n");    fprintf(capdist2,"s/Sav sigma           sigma2      sigma/avsigma\n");    fprintf(capdist3,"s/Sav sigma           sigma2      sigma/avsigma\n");    fprintf(capdist4,"s/Sav sigma           sigma2      sigma/avsigma\n");    fprintf(capdist5,"s/Sav sigma           sigma2      sigma/avsigma\n");  */  //printf("*********\n");  fprintf(densdata,"covv mondens dens2p dens3p dens7p\n");  for (i=0;i<NDATAp1;i++) {    covv=cova[i];    x1=mondensa[i]/(xnsq*NRUN); /* monomer density */    xx=densa[i]/(xnsq*NRUN); /* island density */    double yy=xnsq*NRUN;    fprintf(densdata,"%g  %g       %g       %g       %g\n",covv,x1,xx,dens3a[i]/yy,dens7a[i]/yy);  }  //printf("printed density data\n");  /* now to output island-size distributions */       for(i=0;i<5;i++){    //printf("*\n");    cov=(i+1)*CMAX*.2;    //printf("cov\n");    if(i==0) fprintf(dist1,"s  Ns     s/S      f(u)    sav  \n");    //printf("1\n");    if(i==1) fprintf(dist2,"s  Ns     s/S      f(u)    sav  \n");    //printf("2\n");    if(i==2) fprintf(dist3,"s  Ns     s/S      f(u)    sav  \n");    //printf("3\n");    if(i==3) fprintf(dist4,"s  Ns     s/S      f(u)    sav  \n");    //printf("4\n");    if(i==4) fprintf(dist5,"s  Ns     s/S      f(u)    sav  \n");    //printf("5\n");    //N=%d diffrate=%g CMAX=%g\n",N,diffrate,CMAX);          //printf("finished ifs \n");    xx=0; yy=0; zz=0; sav=0;    for(j=2;j<=isizemax;j++){      xx=xx+islcnta[i][j];      yy=yy+j*islcnta[i][j];    }// end of first j loop    //printf("ran middle j loop\n");    sav=yy/xx;    //printf("start of j loop \n");    for(j=1;j<=isizemax;j++)      {	//printf("j\n");	xx=islcnta[i][j]/(xnsq*NRUN);	yy=j/sav;	zz=xx*sav*sav/cov;		if(xx!=0)  	  {	    //printf("yy\n");	    if(i==0) fprintf(dist1,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==1) fprintf(dist2,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==2) fprintf(dist3,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==3) fprintf(dist4,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	    if(i==4) fprintf(dist5,"%d  %g   %g  %g  %g \n",j,xx,yy,zz,sav);	  }	      }/* end of loop over j */    //printf("end of j loop \n");  }/* end of loop over i */  //printf("end of main loop \n");}/* end of main */void takelogdata (int ilogdata){  int i,j,k,numcl,icntr;  numcl=0;    for(i=0;i<N;i++){    for(j=0;j<N;j++){      imark[i][j]='0';    }}    for(i=0;i<N;i++){    for(j=0;j<N;j++){      //      if(h[i][j]>'0' && imark[i][j]=='0')       if(h[i][j]>0 && imark[i][j]=='0') 	{	  numcl++;isize=1;imark[i][j]='1';	  check(i,j,numcl);// this is recursive call	  if(isize==1)mondensa[ilogdata]=mondensa[ilogdata]+1;	  if(isize>=2)densa[ilogdata]=densa[ilogdata]+1;	  if(isize>=3)dens3a[ilogdata]=dens3a[ilogdata]+1;	  if(isize>=7)dens7a[ilogdata]=dens7a[ilogdata]+1;	}    }/* end of j  =0-N loop */  }/* end of i  =0-N loop */  nwa[ilogdata]=nwa[ilogdata]+nw[0]+nw[2]+nw[3]; // walker density}/* end of takelogdata */void takedistdata (){  int i,j,k,numcl;  double x,y;  for(i=0;i<MAXISLCNT;i++) {    numisizea[i]=0;}/* I added(jga) this here */    for(i=0;i<N;i++){    for(j=0;j<N;j++){      imark[i][j]='0';      numcl=0;    }}  for(i=0;i<N;i++){    for(j=0;j<N;j++){      //      if(h[i][j]>'0' && imark[i][j]=='0'){      if(h[i][j]> 0 && imark[i][j]=='0'){	numcl++;isize=1;imark[i][j]='1';	check(i,j,numcl);	islcnta[idata][isize]=islcnta[idata][isize]+1;	numisizea[isize]=islcnta[idata][isize];	if(isize > isizemax)isizemax=isize;      }    }}/* i,j loop over system */  printf("in takedistdata isizemax=%d\n",isizemax);  /* I added(jga) this */   x=0;  y=0;  for(i=2;i<=isizemax;i++){    y=y+islcnta[idata][i];    x=x+i*islcnta[idata][i];}  sava[idata]=x/y;  printf("sava[%d]=%g\n",idata,sava[idata]);  /* I added(jga) this */     }/* end of takedistdata */void check(int i, int j, int numcl){  int inb,jnb,knb,idir;  for(idir=0;idir<NDIR;idir++){    inb=nbxa[i][idir];    jnb=nbya[j][idir];    if(inb<0 || inb >= N){printf("in check inb=%d\n",inb);abort();}    if(jnb<0 || jnb >= N){printf("in check jnb=%d\n",jnb);abort();}    //    if(h[inb][jnb] >'0' && imark[inb][jnb]=='0'){    if(h[inb][jnb] >0 && imark[inb][jnb]=='0'){      isize++;imark[inb][jnb]='1';      check(inb,jnb,numcl);}  }}void deposit(void){  int i,j,k,dir,index,isite,idir,isitesh,isite2,index2,dir2,ipos,ilen;  unsigned char hc;  i = N*uni();  if(i==N)i=N-1;  j = N*uni();  if(j==N)j=N-1;  printf("we deposit at i=%d j=%d\n",i,j);  //  printf("we are in deposit but should not be i=%d j=%d\n",i,j);  //  abort();  hc=h[i][j];  hc++;  h[i][j]=hc;  //  h[i][j]++;  isitesh=(i*N+j);  //first assign direction   dir=uni()*NDIR;//this is hot direction  !!!  if(dir==NDIR)dir=NDIRM;  //    printf("deposit monomer dir=%d\n",dir);  index=ipointa[isitesh];  if(index==0) {//already a hot walker    dira[0][ipos]=dir;//just change direction  }  else {//if not already a walker    add(0,isitesh,dir,-1);  }  //in all cases update length  ipos=ipointa[isitesh];  ilen=(int)(1.0/uni());  if(ilen==0)ilen=1;  lenwalka[ipos]=ilen;  upnbhd(i,j,dir);//this deletes walker if necesssary and fixes nbrs as necessary  //  abort();  printf("nw0=%d nw1=%d nw2=%d nw3=%d\n",nw[0],nw[1],nw[2],nw[3]);}/* end of void deposit () */void upnbhd(int i, int j, int dir)// update nbhd of i,j,k{  int inb,jnb,knb,dir2,dir3;  update(i,j,dir);  // update the site itself  for(dir2= 0;dir2<NDIR;dir2++){// update the neighbors    inb=nbxa[i][dir2];    jnb=nbya[j][dir2];    update(inb,jnb,-1);    }  }/* end of upnbhd */void update(int i, int j, int dir)  // update i,j{  int isite,index,newindex;  //  printf("we are in update\n");  //  isite=NDIR*(i*N+j)+dir;  dir=0;  isite=i*N+j;  index=indexa[isite];  //  printf("before icount ideposit=%d i=%d j=%d dir=%d index=%d\n",ideposit,i,j,dir,index);  newindex=icount(i,j,dir);  //  printf("after icount ideposit=%d i=%d j=%d dir=%d newindex=%d\n",ideposit,i,j,dir,newindex);  //  if(newindex==1 && dir !=-1)newindex=0;  if(newindex != index){    if(index != -1)delete(index, isite);    int bdir=-1;    if(newindex>=2)bdir=onebonddir;    if(newindex != -1){      add(newindex,isite,dir,bdir);    }  }}// end of update(int i, int j, int dir) void delete(int index, int isite)   {     int ipos,endsite,endpos;     ipos=ipointa[isite];     endpos=nw[index]-1;     endsite=list[index][endpos];     if(endpos != ipos)       {	 // move end to hole in list	 list[index][ipos]=endsite;//move end to hole in list	 ipointa[endsite]=ipos;//reset pointer for endsite to new position (hole)	 if(index==0)lenwalka[ipos]=lenwalka[endpos];	 if(index != 1){	   dira[index][ipos]=dira[index][endpos];	 }       }     indexa[isite]=-1; //indicate no walker at given site     nw[index]=nw[index]-1;//decrement number of walker of given type     // UPDATE TREE BRANCHES BELONGING TO INDEX     uptree(index);   }// end of delete (index, isite) void add(int index, int isite,int idir,int bdir)   {     list[index][nw[index]]=isite;     indexa[isite]=index;     ipointa[isite]=nw[index];     if(index==0)dira[index][nw[index]]=idir;//DIR ADDED !     if(index >= 2)dira[index][nw[index]]=bdir;//BDIR ADDED!     nw[index]=nw[index]+1;     // UPDATE TREE BRANCHES BELONGING TO INDEX     uptree(index);   }// end of add(int index, int isite)int icount(int i, int j, int dir) // this determines class of particle {     // here we only check for monomer (bond in any direction)  int inb, jnb, knb, idir,nbonds,dirp,dirm,hnew,iidir,isite,isitesh;  int ibond,jbond,ichk,ibonda[6],nchk,nchk1,nchk2;  int bdira[10],isave,jsave;  unsigned char hx;  onebonddir=-1;  //check to make sure not blocked "bonded" in direction  //  isitesh=i*N+j;  //  isite=ipointa[isitesh];  int bdir;    hx=h[i][j];    //    if(hx=='0'){return(-1);}    if(hx==0){return(-1);}    //        printf("we just entered icount with h!=0 i=%d j=%d dir=%d\n",i,j,dir);	//        printf("nw0=%d nw1=%d  nw2=%d nw3=%d nw4=%d\n",nw[0],nw[1],nw[2],nw[3],nw[4]);  // now count bonds    //    printf("we are now going to count bonds\n");    //icount=0;    nbonds=0;    for(ichk=0;ichk<NDIR;ichk++){    ibond=nbxa[i][ichk];jbond=nbya[j][ichk];    if(h[ibond][jbond]>=hx)  {nbonds=nbonds+1;isave=ibond;jsave=jbond; bdir=ichk;}    if(nbonds>=2)return(-1);    }  //so we have either 0 bonds or 1 bond   if(nbonds==0){    if(dir==-1)return(1);//thermal monomer    else return(0);//hot monomer  }  //so nbonds=1 could be a dimer or a cluster   //check for dimer  onebonddir=bdir;//save onebond direction in global variable "onebonddir"    nbonds=0;  for(int ichk=0;ichk<NDIR;ichk++){    int ii=nbxa[isave][ichk];    int jj=nbya[jsave][ichk];    if(h[ii][jj]>=h[isave][jsave]) { nbonds=nbonds+1;if(nbonds >= 2)break;}  }  if(nbonds>=2)return(3);//one-bond attached to larger cluster  else return(2);//one-bond attached to dimer}/* end of int icount (int i, int j, int dir)  */void diffuse(){  int x,y,i,j,hxy,a,b,site,isite,isitesh,isitenewsh;  int dir,bdir,iwalk,xi,yi,itype;     double xtemp,partial,s1,s2,s3;     int sum,ih,ipos,iposnew;  int xnb,ynb,idir,islmark;  int inb,jnb,ilen,dirr;     xtemp = tree[0][0]*uni();     j = 0;     for (i=0;i<2;i++) {          if (xtemp > tree[i+1][2*j]) {	      xtemp = xtemp - tree[i+1][2*j];	      j = 2*j+1;	  }	  else {	      j = 2*j;	  }         }     itype = j;     iwalk = uni()*nw[itype];     if (iwalk==nw[itype]) iwalk = nw[itype]-1; //fixed JGA 2/26/11     isite  = list[itype][iwalk];//isite=x*N+y     //     dir   = site % NDIR;     //     isite = site /NDIR;//  isite=NDIR*(i*N+j)+dir;     x     = isite/N;     y     = isite % N;     idiffuse++;     //     printf("we diffuse from %d,%d itype=%d iwalk=%d\n",x,y,itype,iwalk);     //we need to get dir which is either random for type 1, or equal to dira[0][iwalk] for type 0      // or more complicated for types 2 and 3     if(itype==0){       dir=dira[0][iwalk];     }     else {       if(itype==1){	 dir=uni()*NDIR;	 if(dir==NDIR)dir=NDIR-1;       }       else {	 //now we have types 2 or 3	 if(itype==2){ //dimer	   bdir=dira[2][iwalk];	   	   dirr=uni()*3+2;	   if(dirr==5)dirr=4;	   dir=(bdir+dirr)%NDIR;//3 detach directions	 }	 else {	   //this is one-bond cluster 	   if(uni() < pdetach){	     //we detach	   int bdir=dira[3][iwalk];	   	   dirr=uni()*3+2;	   if(dirr==5)dirr=4;	   dir=(bdir+dirr)%NDIR;//3 detach directions	   }	   else {	     //we edge-diffuse	     bdir=dira[3][iwalk];	     dirr=uni()*2;	     if(dirr==2)dirr=1;	     if(dirr==0)dirr=5;	     dir=(bdir+dirr)%NDIR;//2 edge-diffusion directions	   }	 }       }     }  h[x][y]--;  xnb=nbxa[x][dir];  ynb=nbya[y][dir];  //  ih=h[xnb][ynb];  h[xnb][ynb]++;  //    printf("we are in diffuse i=%d j=%d h=%d -> in=%d jn=%d h=%d \n",x,y,h[x][y],xnb,ynb,h[xnb][ynb]);  if(itype!=0)dir=-1;#ifdef LEVY  if(itype==0){    ipos=ipointa[x*N+y];    lenwalka[ipos]=lenwalka[ipos]-1;    if(lenwalka[ipos]==0){      dir=uni()*NDIR;      if(dir==NDIRM)dir=0;      ilen=(int)(1.0/uni());      if(ilen==0)ilen=1;      lenwalka[ipos]=ilen;    }  }#endif  upnbhd(x,y,dir);  upnbhd(xnb,ynb,dir);}/* end of diffuse () */void capnum(int icdata){  int i,irun;  double mondens,denom,xncubdcovn1,msigma,dmsigma;  double density,scaledsigma,dcov,densi;    dcov=CMAX*0.2;  xncubdcovn1 = diffq*islcnta[icdata][1]*.05*(icdata+1)*dcov/NRUN;  density = 0.0;  msigma = 0.0;  printf("in capnum icdata=%d isizemax=%d\n",icdata,isizemax);  for(i=2;i<=isizemax;i++){  densi=islcnta[icdata][i]/xnsq;  denom=xncubdcovn1*densi;  density = density + densi;	if(denom>0) {/* I added(jga) brackets here */ tsigma[i]=ct[i][icdata]/denom;	//	msigma = msigma + tsigma[i]*densi;	//		avsigma[icdata]=avsigma[icdata] + dmsigma;	//	avsigma[icdata]=tsigma[i]*densi;				sigma[i][icdata]=sigma[i][icdata]+tsigma[i];		//		sigma2[i][icdata]=sigma2[i][icdata]+tsigma[i]*tsigma[i];	}/* I added(jga) brackets here */  }	//		dmsigma=msigma/density;	//		avsigma2[icdata]=avsigma2[icdata] + (dmsigma*dmsigma);				printf("leaving capnum\n");}/* end of void capnum(int icdata) */    /* uni.c */    /* 3D triangulation program written by Isabel Beichl */    /* based on an algorithm designed by Isabel Beichl & Francis Sullivan */    /*    National Institute of Standards & Technology */    /*    Gaithersburg, MD 20899  */          static unsigned long count = 0;    #define BIGCOUNT 10000000    /* how many to do without re-initializing */    static unsigned long m1 = 32767;    static long int mb[607];    /*=    {            30788, 23052, 2053, 19346, 10646, 19427, 23975,            19049, 10949, 19693, 29746, 26748, 2796, 23890,            29168, 31924, 16499    };    */    static int mdig = 32;    static unsigned long m2 = 256;    static int iran = 272;    static int jran = 606;    double suni(jseed)          unsigned long jseed;    {            long int j0, j1, k0, k1;            double uni();    /*      printf(" suni %ld\n", jseed);*/            m1 = poww2(mdig-2) - 1;     /* avoid overflow if m1 is full size */            m1 += m1;            m1++;       /* printf(" m1 %lu, m2 %lu, mdig %d, jseed %u\n", m1, m2, mdig, jseed); */            m2 = poww2((int)(mdig/2));       /* printf(" m1 %lu, m2 %lu, mdig %d, jseed %u\n", m1, m2, mdig, jseed); */            jseed %= m1;                    /* jseed should less than m1 */            if ((jseed & 1) == 0)           /* jseed should be odd */                    jseed--;            k0 = 9069 % m2;                 /* simple congruential generator */            k1 = 9069 / m2;                 /* the fanciness avoids overflow */            j0 = jseed % m2;            j1 = jseed / m2;            for (iran = 0; iran < 607; iran++)            {       jseed = j0*k0;                    j1 = (jseed/m2 + j0*k1 + j1*k0) % (m2/2);                    j0 = jseed % m2;                    mb[iran] = j0 + m2*j1;        /* printf("%2d %10u\n", i, mb[i]); */            }            iran = 272;            jran = 606;            return uni();    }    double uni()    {            long int k;            k = mb[iran] - mb[jran];            if (k < 0)                    k += m1;       /* printf(" In UNI -- k = %ld\n",k); */            if (++count >= BIGCOUNT)            {       count = 0;                    suni(k);            }            else            {       mb[jran] = k;                    if (--iran < 0)                            iran = 606;                    if (--jran < 0)                            jran = 606;            }       /* printf("%lf\n", (double)k/(double)m1); */       /* putchar(k%2 ?'+':'-');*/            return ((double)k/(double)m1);    }unsigned long poww2(int j)    {            unsigned long x = 1;       /* printf("poww2--j= %d\n",j); */            while (j--)                    x *= 2;          /* printf("poww2--x= %lu\n",x); */            return (unsigned long) x;    }    /* end of uni2.c */void sumtree(){     int i,j,nj,a;     nj = 2;     for (i=1;i>=0;i--){          for (j=0;j<nj;j++){               tree[i][j]=tree[i+1][2*j]+tree[i+1][2*j+1];              }          nj = (int) (nj/2);     }}     void uptree(int index){     int i,j,a;     double nwrate;     nwrate = nw[index]*Rate[index];     if (tree[2][index]!=nwrate) {         tree[2][index]=nwrate;         j = (int) (index/2);         for (i=1;i>=0;i--){              tree[i][j]=tree[i+1][2*j]+tree[i+1][2*j+1];	      j = (int) (j/2);         }     }	}     	  